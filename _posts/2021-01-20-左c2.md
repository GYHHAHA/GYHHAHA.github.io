---
layout: post
title: 左c2
categories: 算法与数据结构
tags: 
author: GYH
---

* content
{:toc}

## [左c2n1：打印两个升序链表的公共部分](https://www.nowcoder.com/practice/8943eea40dbb4185b187d80fd050fee9?tpId=101&&tqId=33116&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

## 思路

这个地方需要注意，不是链表公共相交的部分，而是公共的元素，因此只需小值追赶大值即可。

## 代码

```
void sol(list_node * a_head, list_node * b_head)
{
    //////在下面完成代码
    while (a_head != NULL && b_head != NULL){
        if (a_head->val < b_head->val){
            a_head = a_head->next;
        }else if (a_head->val > b_head->val){
            b_head = b_head->next;
        }else{
            cout << a_head->val << " ";
            a_head = a_head->next;
            b_head = b_head->next;
        }
    }
    cout << endl;
}
```

## [左c2n2：在链表中删除倒数第K个节点](https://www.nowcoder.com/practice/e5d90aac4c8b4628aa70d9b6597c0560?tpId=101&&tqId=33117&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

## 思路

对于删除倒数第K个节点，先遍历链表每次减去1，最后K变成K-N，再从头来对每个节点一个个加1，直到K为0。此时，当前指针在被删除的前一个节点，此时只需要连接到后面再后面一个节点即可。

这里需要注意两个边界情况，第一个是当K<=0或者空指针时直接返回head本身，第二个是删除的为第一个节点的时候，需要直接返回第二个节点。

## 代码

```
list_node * remove_last_kth_node(list_node * head, int K)
{
    //////在下面完成代码
    if (K<=0||head==0){
        return head;
    }
    list_node* cur = head;
    --K;
    while (cur->next){
        --K;
        cur = cur->next;
    }
    if (K==0){
        return head->next;
    }
    cur = head;
    ++K;
    while (K<0){
        ++K;
        cur = cur->next;
    }
    cur->next = cur->next->next;
    return head;
}
```

## [左c2n3：删除链表的中间节点](https://www.nowcoder.com/practice/0796dbf0eb054716937b0b82e0671c5f?tpId=101&&tqId=33174&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

## 思路

本题对于快慢指针的最优解法而言，由于需要拿到删除节点的前一个节点，因此初始快慢指针的位置很有讲究，即cur=head且fast=head->next->next。

## 代码（删除第K个节点）

```
list_node * remove_kth_node(list_node * head, int K)
{
    list_node* cur = head;
    //////在下面完成代码
    if (K<=0){
        return head;
    }
    if (K==1){
        return head->next;
    }
    while ((--K)!=1){
        cur = cur->next;
    }
    cur->next = cur->next->next;
    return head;
}
```

## 代码（删除中间节点）

```
list_node * remove_kth_node(list_node * head, int K)
{
    if (head==0 || head->next==0){
        return head;
    }else if (head->next->next==0){
        return head->next;
    }else{
        list_node* slow = head;
        list_node* fast = head->next->next;
        while (fast->next!=0 && fast->next->next!=0){
            slow = slow->next;
            fast = fast->next->next;
        }
        slow->next = slow->next->next;
        return head;
    }
}
```